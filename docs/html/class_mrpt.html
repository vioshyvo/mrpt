<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Mrpt: Mrpt Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="extree3.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Mrpt
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="class_mrpt-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Mrpt Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>The constructor does not actually build the index. The building is done by the function <a class="el" href="class_mrpt.html#a7d789c72d12dd668fc5ffb157a9a52f4">grow()</a> which has to be called before queries can be made. There are two different versions of the constructor which differ only by the type of the input data. The first version takes the data set as <code>Ref</code> to <code>MatrixXf</code>, which means that the argument can be either <code>MatrixXf</code> or <code>Map&lt;MatrixXf&gt;</code> (also certain blocks of <code>MatrixXf</code> may be accepted, see <a href="https://eigen.tuxfamily.org/dox/TopicFunctionTakingEigenTypes.html">Eigen::Ref</a> for more information). The second version takes a float pointer to an array containing the data set, and the dimension and the sample size of the data. There are also corresponding versions of all the member functions which take input data. In all cases the data is assumed to be stored in column-major order such that each data point is stored contiguously in memory. In all cases no copies are made of the original data matrix. </p>
</div></td></tr>
<tr class="memitem:a1e77a5c97c6ae94d17162f65041821bc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mrpt.html#a1e77a5c97c6ae94d17162f65041821bc">Mrpt</a> (const Eigen::Ref&lt; const Eigen::MatrixXf &gt; &amp;X_)</td></tr>
<tr class="separator:a1e77a5c97c6ae94d17162f65041821bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e4195e845c91014df816f4e27a38b48"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mrpt.html#a4e4195e845c91014df816f4e27a38b48">Mrpt</a> (const float *X_, int dim_, int n_samples_)</td></tr>
<tr class="separator:a4e4195e845c91014df816f4e27a38b48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Normal index building.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Build a normal (not autotuned) index. </p>
</div></td></tr>
<tr class="memitem:a7d789c72d12dd668fc5ffb157a9a52f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mrpt.html#a7d789c72d12dd668fc5ffb157a9a52f4">grow</a> (int n_trees_, int depth_, float density_=-1.0, int seed=0)</td></tr>
<tr class="separator:a7d789c72d12dd668fc5ffb157a9a52f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Autotuned index building</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Builds an index by autotuning such that the parameters giving the fastest query time at the target recall level are found. If the target recall level is not reached at all, then an index giving the highest recall level is built. The <a class="el" href="class_mrpt.html#a82a6cd3ce04ff8307bfd00d99fc5400a">parameters()</a> function can be used to retrieve these optimal parameter values and the estimated query time and the estimated recall. There is a version which uses a separate set of test queries (<code>grow</code>), and a version which samples a test set from the data set (<code>grow_autotune</code>). </p>
</div></td></tr>
<tr class="memitem:a7360964458339aab0ddedde324a03e47"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mrpt.html#a7360964458339aab0ddedde324a03e47">grow</a> (double target_recall, const Eigen::Ref&lt; const Eigen::MatrixXf &gt; &amp;Q, int k_, int trees_max=-1, int depth_max=-1, int depth_min_=-1, int votes_max_=-1, float density=-1.0, int seed=0)</td></tr>
<tr class="separator:a7360964458339aab0ddedde324a03e47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bf7a8162fc7f6bd56d10097aeedffc8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mrpt.html#a2bf7a8162fc7f6bd56d10097aeedffc8">grow</a> (double target_recall, const float *Q, int n_test, int k_, int trees_max=-1, int depth_max=-1, int depth_min_=-1, int votes_max_=-1, float density=-1.0, int seed=0, const std::vector&lt; int &gt; &amp;indices_test={})</td></tr>
<tr class="separator:a2bf7a8162fc7f6bd56d10097aeedffc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6911b63fb6fb87129f893831391f42dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mrpt.html#a6911b63fb6fb87129f893831391f42dd">grow_autotune</a> (double target_recall, int k_, int trees_max=-1, int depth_max=-1, int depth_min_=-1, int votes_max_=-1, float density_=-1.0, int seed=0, int n_test=100)</td></tr>
<tr class="separator:a6911b63fb6fb87129f893831391f42dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82a6cd3ce04ff8307bfd00d99fc5400a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_mrpt___parameters.html">Mrpt_Parameters</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mrpt.html#a82a6cd3ce04ff8307bfd00d99fc5400a">parameters</a> () const</td></tr>
<tr class="separator:a82a6cd3ce04ff8307bfd00d99fc5400a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64adc0d6952d12e4599459f8654e860e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mrpt.html#a64adc0d6952d12e4599459f8654e860e">is_autotuned</a> () const</td></tr>
<tr class="separator:a64adc0d6952d12e4599459f8654e860e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Autotuned index building without preset recall level</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Build an autotuned index. This version does not require prespecifying a target recall level, but an index generated by this function can be used to subset different indices with different recall levels. This is done by <a class="el" href="class_mrpt.html#add8686a73cfae8d8391e85314acbe81a">subset()</a>. The function <a class="el" href="class_mrpt.html#a0907893c90a6255d3cf8d11e940c6ce3">optimal_parameters()</a> can be used to retrieve a pareto frontier of optimal parameters. There is a version which uses a separate set of test queries (<code>grow</code>), and a version which samples a test set from the data set (<code>grow_autotune</code>). </p>
</div></td></tr>
<tr class="memitem:a40eae6f75c79b4ff0f5400b14f8d81c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mrpt.html#a40eae6f75c79b4ff0f5400b14f8d81c2">grow</a> (const float *data, int n_test, int k_, int trees_max=-1, int depth_max=-1, int depth_min_=-1, int votes_max_=-1, float density_=-1.0, int seed=0, const std::vector&lt; int &gt; &amp;indices_test={})</td></tr>
<tr class="separator:a40eae6f75c79b4ff0f5400b14f8d81c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a6325435fc140ac5394c2f0136ea211"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mrpt.html#a7a6325435fc140ac5394c2f0136ea211">grow</a> (const Eigen::Ref&lt; const Eigen::MatrixXf &gt; &amp;Q, int k_, int trees_max=-1, int depth_max=-1, int depth_min_=-1, int votes_max_=-1, float density_=-1.0, int seed=0)</td></tr>
<tr class="separator:a7a6325435fc140ac5394c2f0136ea211"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ee717a90c0548f31577b033540dda44"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mrpt.html#a9ee717a90c0548f31577b033540dda44">grow_autotune</a> (int k_, int trees_max=-1, int depth_max=-1, int depth_min_=-1, int votes_max_=-1, float density_=-1.0, int seed=0, int n_test=100)</td></tr>
<tr class="separator:a9ee717a90c0548f31577b033540dda44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add8686a73cfae8d8391e85314acbe81a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_mrpt.html">Mrpt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mrpt.html#add8686a73cfae8d8391e85314acbe81a">subset</a> (double target_recall) const</td></tr>
<tr class="separator:add8686a73cfae8d8391e85314acbe81a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dc319eab5e2bc9a5a6d7a6007cef34d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_mrpt.html">Mrpt</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mrpt.html#a4dc319eab5e2bc9a5a6d7a6007cef34d">subset_pointer</a> (double target_recall) const</td></tr>
<tr class="separator:a4dc319eab5e2bc9a5a6d7a6007cef34d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0907893c90a6255d3cf8d11e940c6ce3"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="struct_mrpt___parameters.html">Mrpt_Parameters</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mrpt.html#a0907893c90a6255d3cf8d11e940c6ce3">optimal_parameters</a> () const</td></tr>
<tr class="separator:a0907893c90a6255d3cf8d11e940c6ce3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Approximate k-nn search</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>A query using a non-autotuned index. Finds k approximate nearest neighbors from a data set X for a query point q. Because the index is not autotuned, k and vote threshold are set manually. The indices of k nearest neighbors are written to a buffer out, which has to be preallocated to have at least length k. Optionally also Euclidean distances to these k nearest points are written to a buffer out_distances. If there are less than k points in the candidate set, -1 is written to the remaining locations of the output buffers. </p>
</div></td></tr>
<tr class="memitem:a637e67fe6eba9a6711f5eee65ad4a0da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mrpt.html#a637e67fe6eba9a6711f5eee65ad4a0da">query</a> (const float *data, int k, int vote_threshold, int *out, float *out_distances=nullptr, int *out_n_elected=nullptr) const</td></tr>
<tr class="separator:a637e67fe6eba9a6711f5eee65ad4a0da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35235eb7acf4bff5fbfb12c9cd82f0b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mrpt.html#a35235eb7acf4bff5fbfb12c9cd82f0b8">query</a> (const Eigen::Ref&lt; const Eigen::VectorXf &gt; &amp;q, int k, int vote_threshold, int *out, float *out_distances=nullptr, int *out_n_elected=nullptr) const</td></tr>
<tr class="separator:a35235eb7acf4bff5fbfb12c9cd82f0b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Approximate k-nn search using autotuned index</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Approximate k-nn search using an autotuned index. Finds k approximate nearest neighbors from a data set X for a query point q. Because the index is autotuned, no parameters other than a query point and an output are required: k is preset, and the optimal vote count is used automatically. The indices of k nearest neighbors are written to a buffer out, which has to be preallocated to have at least length k. Optionally also the Euclidean distances to these k nearest points are written to a buffer out_distances. If there are less than k points in the candidate set, -1 is written to the remaining locations of the output buffers. </p>
</div></td></tr>
<tr class="memitem:a16fac96c266abcc778694e0b0cdc5f3c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mrpt.html#a16fac96c266abcc778694e0b0cdc5f3c">query</a> (const float *q, int *out, float *out_distances=nullptr, int *out_n_elected=nullptr) const</td></tr>
<tr class="separator:a16fac96c266abcc778694e0b0cdc5f3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9579b70d0553126363f6112a10ffb0eb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mrpt.html#a9579b70d0553126363f6112a10ffb0eb">query</a> (const Eigen::Ref&lt; const Eigen::VectorXf &gt; &amp;q, int *out, float *out_distances=nullptr, int *out_n_elected=nullptr) const</td></tr>
<tr class="separator:a9579b70d0553126363f6112a10ffb0eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Utility functions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Saving and loading an index and checking if it is already constructed. Saving and loading work for both autotuned and non-autotuned indices, and <a class="el" href="class_mrpt.html#af31f777278ec7030e7351b6ed57ca766">load()</a> retrieves also the optimal parameters found by autotuning. The same data set used to build a saved index has to be used to construct the index into which it is loaded. </p>
</div></td></tr>
<tr class="memitem:af936713e7629e08e88d11346f2639ba0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mrpt.html#af936713e7629e08e88d11346f2639ba0">save</a> (const char *path) const</td></tr>
<tr class="separator:af936713e7629e08e88d11346f2639ba0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af31f777278ec7030e7351b6ed57ca766"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mrpt.html#af31f777278ec7030e7351b6ed57ca766">load</a> (const char *path)</td></tr>
<tr class="separator:af31f777278ec7030e7351b6ed57ca766"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a960f1af81f2b56db7eb8cd0d5a352c14"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mrpt.html#a960f1af81f2b56db7eb8cd0d5a352c14">empty</a> () const</td></tr>
<tr class="separator:a960f1af81f2b56db7eb8cd0d5a352c14"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Friend declarations for test fixtures. Tests are located at <a href="https://github.com/vioshyvo/RP-test">https://github.com/vioshyvo/RP-test</a>. </p>
</div></td></tr>
<tr class="memitem:ad0e0eebd68b89d6815155d43dfc795e0"><td class="memItemLeft" align="right" valign="top"><a id="ad0e0eebd68b89d6815155d43dfc795e0"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>MrptTest</b></td></tr>
<tr class="separator:ad0e0eebd68b89d6815155d43dfc795e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31cb77f9b824d3edec0f45c217d87e12"><td class="memItemLeft" align="right" valign="top"><a id="a31cb77f9b824d3edec0f45c217d87e12"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>UtilityTest</b></td></tr>
<tr class="separator:a31cb77f9b824d3edec0f45c217d87e12"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Exact k-nn search</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp66e70173778f5cb6ed500f1b08ac9e49"></a>Functions for fast exact k-nn search: find k nearest neighbors for a query point q from a data set X_. The indices of k nearest neighbors are written to a buffer out, which has to be preallocated to have at least length k. Optionally also the Euclidean distances to these k nearest points are written to a buffer out_distances. There are both static and member versions. </p>
</td></tr>
<tr class="memitem:a708704bc812a926c1dc950c267ae513b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mrpt.html#a708704bc812a926c1dc950c267ae513b">exact_knn</a> (const float *q, int k, int *out, float *out_distances=nullptr) const</td></tr>
<tr class="separator:a708704bc812a926c1dc950c267ae513b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24f2dfef8d422cb875abd18d411d47a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mrpt.html#a24f2dfef8d422cb875abd18d411d47a1">exact_knn</a> (const Eigen::Ref&lt; const Eigen::VectorXf &gt; &amp;q, int k, int *out, float *out_distances=nullptr) const</td></tr>
<tr class="separator:a24f2dfef8d422cb875abd18d411d47a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19867c3d3f83e50c88e1edde63a81985"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mrpt.html#a19867c3d3f83e50c88e1edde63a81985">exact_knn</a> (const float *q_data, const float *X_data, int dim, int n_samples, int k, int *out, float *out_distances=nullptr)</td></tr>
<tr class="separator:a19867c3d3f83e50c88e1edde63a81985"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab06ab10bca1f953c6581f7d412b4661c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mrpt.html#ab06ab10bca1f953c6581f7d412b4661c">exact_knn</a> (const Eigen::Ref&lt; const Eigen::VectorXf &gt; &amp;q, const Eigen::Ref&lt; const Eigen::MatrixXf &gt; &amp;X, int k, int *out, float *out_distances=nullptr)</td></tr>
<tr class="separator:ab06ab10bca1f953c6581f7d412b4661c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a1e77a5c97c6ae94d17162f65041821bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e77a5c97c6ae94d17162f65041821bc">&#9670;&nbsp;</a></span>Mrpt() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Mrpt::Mrpt </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXf &gt; &amp;&#160;</td>
          <td class="paramname"><em>X_</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">X_</td><td>Eigen ref to the data set, stored as one data point per column </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4e4195e845c91014df816f4e27a38b48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e4195e845c91014df816f4e27a38b48">&#9670;&nbsp;</a></span>Mrpt() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Mrpt::Mrpt </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>X_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dim_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n_samples_</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">X_</td><td>a float array containing the data set with each data point stored contiguously in memory </td></tr>
    <tr><td class="paramname">dim_</td><td>dimension of the data </td></tr>
    <tr><td class="paramname">n_samples_</td><td>number of data points </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a960f1af81f2b56db7eb8cd0d5a352c14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a960f1af81f2b56db7eb8cd0d5a352c14">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Mrpt::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Is the index is already constructed or not?</p>
<dl class="section return"><dt>Returns</dt><dd>- is the index empty? </dd></dl>

</div>
</div>
<a id="a19867c3d3f83e50c88e1edde63a81985"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19867c3d3f83e50c88e1edde63a81985">&#9670;&nbsp;</a></span>exact_knn() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Mrpt::exact_knn </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>q_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>X_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n_samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>out_distances</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q_data</td><td>pointer to an array containing the query point </td></tr>
    <tr><td class="paramname">X_data</td><td>pointer to an array containing the data set </td></tr>
    <tr><td class="paramname">dim</td><td>dimension of data </td></tr>
    <tr><td class="paramname">n_samples</td><td>number of points in a data set </td></tr>
    <tr><td class="paramname">k</td><td>number of neighbors searched for </td></tr>
    <tr><td class="paramname">out</td><td>output buffer (size = k) for the indices of k nearest neighbors </td></tr>
    <tr><td class="paramname">out_distances</td><td>optional output buffer (size = k) for the distances to k nearest neighbors </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab06ab10bca1f953c6581f7d412b4661c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab06ab10bca1f953c6581f7d412b4661c">&#9670;&nbsp;</a></span>exact_knn() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Mrpt::exact_knn </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXf &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXf &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>out_distances</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>Eigen ref to a query point </td></tr>
    <tr><td class="paramname">X</td><td>Eigen ref to a data set </td></tr>
    <tr><td class="paramname">k</td><td>number of neighbors searched for </td></tr>
    <tr><td class="paramname">out</td><td>output buffer (size = k) for the indices of k nearest neighbors </td></tr>
    <tr><td class="paramname">out_distances</td><td>optional output buffer (size = k) for the distances to k nearest neighbors </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a708704bc812a926c1dc950c267ae513b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a708704bc812a926c1dc950c267ae513b">&#9670;&nbsp;</a></span>exact_knn() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Mrpt::exact_knn </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>out_distances</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>pointer to an array containing the query point </td></tr>
    <tr><td class="paramname">k</td><td>number of neighbors searched for </td></tr>
    <tr><td class="paramname">out</td><td>output buffer (size = k) for the indices of k nearest neighbors </td></tr>
    <tr><td class="paramname">out_distances</td><td>optional output buffer (size = k) for the distances to k nearest neighbors </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a24f2dfef8d422cb875abd18d411d47a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24f2dfef8d422cb875abd18d411d47a1">&#9670;&nbsp;</a></span>exact_knn() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Mrpt::exact_knn </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXf &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>out_distances</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>pointer to an array containing the query point </td></tr>
    <tr><td class="paramname">k</td><td>number of points searched for </td></tr>
    <tr><td class="paramname">out</td><td>output buffer (size = k) for the indices of k nearest neighbors </td></tr>
    <tr><td class="paramname">out_distances</td><td>optional output buffer (size = k) for the distances to k nearest neighbors </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7d789c72d12dd668fc5ffb157a9a52f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d789c72d12dd668fc5ffb157a9a52f4">&#9670;&nbsp;</a></span>grow() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Mrpt::grow </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n_trees_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depth_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>density_</em> = <code>-1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>seed</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Build a normal index.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n_trees_</td><td>number of trees to be grown </td></tr>
    <tr><td class="paramname">depth_</td><td>depth of the trees; in the set <img class="formulaInl" alt="$\{1,2, \dots ,\lfloor \log_2 (n) \rfloor \}$" src="form_4.png"/>, where <img class="formulaInl" alt="$n $" src="form_5.png"/> is the number of data points </td></tr>
    <tr><td class="paramname">density_</td><td>expected proportion of non-zero components in the random vectors; on the interval <img class="formulaInl" alt="$(0,1]$" src="form_6.png"/>; default value sets density to <img class="formulaInl" alt="$ 1 / \sqrt{d} $" src="form_2.png"/>, where <img class="formulaInl" alt="$d$" src="form_3.png"/> is the dimension of the data </td></tr>
    <tr><td class="paramname">seed</td><td>seed given to a rng when generating random vectors; a default value 0 initializes the rng randomly with std::random_device </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7360964458339aab0ddedde324a03e47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7360964458339aab0ddedde324a03e47">&#9670;&nbsp;</a></span>grow() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Mrpt::grow </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>target_recall</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXf &gt; &amp;&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>trees_max</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depth_max</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depth_min_</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>votes_max_</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>density</em> = <code>-1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>seed</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Build an autotuned index.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target_recall</td><td>target recall level; on the range [0,1] </td></tr>
    <tr><td class="paramname">Q</td><td>Eigen ref to the the test queries (col = data point, row = dimension). </td></tr>
    <tr><td class="paramname">k_</td><td>number of nearest neighbors searched for </td></tr>
    <tr><td class="paramname">trees_max</td><td>number of trees grown; default value -1 sets this to <img class="formulaInl" alt="$ \mathrm{min}(\sqrt{n}, 1000)$" src="form_16.png"/>, where <img class="formulaInl" alt="$n$" src="form_10.png"/> is the number of data points. </td></tr>
    <tr><td class="paramname">depth_max</td><td>maximum depth of trees considered when searching for optimal parameters; in the set <img class="formulaInl" alt="$\{1,2, \dots ,\lfloor \log_2 (n) \rfloor \}$" src="form_4.png"/>, where <img class="formulaInl" alt="$n $" src="form_5.png"/> is the number of data points; default value -1 sets this to <img class="formulaInl" alt="$ \log_2(n) - 4 $" src="form_9.png"/>, where <img class="formulaInl" alt="$n$" src="form_10.png"/> is the number of data points </td></tr>
    <tr><td class="paramname">depth_min_</td><td>minimum depth of trees considered when searching for optimal parameters; in the set <img class="formulaInl" alt="$\{1,2, \dots ,\lfloor \log_2 (n) \rfloor \}$" src="form_4.png"/>; a default value -1 sets this to 5 </td></tr>
    <tr><td class="paramname">votes_max_</td><td>maximum number of votes considered when searching for optimal parameters; a default value -1 sets this to <img class="formulaInl" alt="$ \mathrm{max}(\lfloor \mathrm{trees\_max} / 10 \rfloor, 10) $" src="form_14.png"/> </td></tr>
    <tr><td class="paramname">density</td><td>expected proportion of non-zero components in the random vectors; default value -1.0 sets this to <img class="formulaInl" alt="$ 1 / \sqrt{d} $" src="form_2.png"/>, where <img class="formulaInl" alt="$ d$" src="form_13.png"/> is the dimension of data </td></tr>
    <tr><td class="paramname">seed</td><td>seed given to a rng when generating random vectors; a default value 0 initializes the rng randomly with std::random_device </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2bf7a8162fc7f6bd56d10097aeedffc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bf7a8162fc7f6bd56d10097aeedffc8">&#9670;&nbsp;</a></span>grow() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Mrpt::grow </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>target_recall</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n_test</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>trees_max</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depth_max</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depth_min_</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>votes_max_</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>density</em> = <code>-1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>seed</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices_test</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Build an autotuned index.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target_recall</td><td>target recall level; on the range [0,1] </td></tr>
    <tr><td class="paramname">Q</td><td>float array containing the test queries </td></tr>
    <tr><td class="paramname">n_test</td><td>number of test queries </td></tr>
    <tr><td class="paramname">k_</td><td>number of nearest neighbors searched for </td></tr>
    <tr><td class="paramname">trees_max</td><td>number of trees grown; default value -1 sets this to <img class="formulaInl" alt="$ \mathrm{min}(\sqrt{n}, 1000)$" src="form_16.png"/>, where <img class="formulaInl" alt="$n$" src="form_10.png"/> is the number of data points. </td></tr>
    <tr><td class="paramname">depth_max</td><td>maximum depth of trees considered when searching for optimal parameters; in the set <img class="formulaInl" alt="$\{1,2, \dots ,\lfloor \log_2 (n) \rfloor \}$" src="form_4.png"/>, where <img class="formulaInl" alt="$n $" src="form_5.png"/> is the number of data points; default value -1 sets this to <img class="formulaInl" alt="$ \log_2(n) - 4 $" src="form_9.png"/>, where <img class="formulaInl" alt="$n$" src="form_10.png"/> is the number of data points </td></tr>
    <tr><td class="paramname">depth_min_</td><td>minimum depth of trees considered when searching for optimal parameters; in the set <img class="formulaInl" alt="$\{1,2, \dots ,\lfloor \log_2 (n) \rfloor \}$" src="form_4.png"/>; a default value -1 sets this to 5 </td></tr>
    <tr><td class="paramname">votes_max_</td><td>maximum number of votes considered when searching for optimal parameters; a default value -1 sets this to <img class="formulaInl" alt="$ \mathrm{max}(\lfloor \mathrm{trees\_max} / 10 \rfloor, 10) $" src="form_14.png"/> </td></tr>
    <tr><td class="paramname">density</td><td>expected proportion of non-zero components in the random vectors; default value -1.0 sets this to <img class="formulaInl" alt="$ 1 / \sqrt{d} $" src="form_2.png"/>, where <img class="formulaInl" alt="$ d$" src="form_13.png"/> is the dimension of data </td></tr>
    <tr><td class="paramname">seed</td><td>seed given to a rng when generating random vectors; a default value 0 initializes the rng randomly with std::random_device </td></tr>
    <tr><td class="paramname">indices_test</td><td>parameter used by the version which uses no separate test set, leave empty. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a40eae6f75c79b4ff0f5400b14f8d81c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40eae6f75c79b4ff0f5400b14f8d81c2">&#9670;&nbsp;</a></span>grow() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Mrpt::grow </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n_test</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>trees_max</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depth_max</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depth_min_</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>votes_max_</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>density_</em> = <code>-1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>seed</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices_test</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Build an autotuned index without prespecifying a recall level.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>a float array containing the test queries. </td></tr>
    <tr><td class="paramname">n_test</td><td>number of test queries </td></tr>
    <tr><td class="paramname">k_</td><td>number of nearest neighbors searched for </td></tr>
    <tr><td class="paramname">trees_max</td><td>number of trees grown; default value -1 sets this to <img class="formulaInl" alt="$ \mathrm{min}(\sqrt{n}, 1000)$" src="form_16.png"/>, where <img class="formulaInl" alt="$n$" src="form_10.png"/> is the number of data points. </td></tr>
    <tr><td class="paramname">depth_max</td><td>maximum depth of trees considered when searching for optimal parameters; in the set <img class="formulaInl" alt="$\{1,2, \dots ,\lfloor \log_2 (n) \rfloor \}$" src="form_4.png"/>, where <img class="formulaInl" alt="$n $" src="form_5.png"/> is the number of data points; default value -1 sets this to <img class="formulaInl" alt="$ \log_2(n) - 4 $" src="form_9.png"/>, where <img class="formulaInl" alt="$n$" src="form_10.png"/> is the number of data points </td></tr>
    <tr><td class="paramname">depth_min_</td><td>minimum depth of trees considered when searching for optimal parameters; in the set <img class="formulaInl" alt="$\{1,2, \dots ,\lfloor \log_2 (n) \rfloor \}$" src="form_4.png"/>; a default value -1 sets this to 5 </td></tr>
    <tr><td class="paramname">votes_max_</td><td>maximum number of votes considered when searching for optimal parameters; a default value -1 sets this to <img class="formulaInl" alt="$ \mathrm{max}(\lfloor \mathrm{trees\_max} / 10 \rfloor, 10) $" src="form_14.png"/> </td></tr>
    <tr><td class="paramname">density_</td><td>expected proportion of non-zero components in the random vectors; default value -1.0 sets this to <img class="formulaInl" alt="$ 1 / \sqrt{d} $" src="form_2.png"/>, where <img class="formulaInl" alt="$ d$" src="form_13.png"/> is the dimension of data </td></tr>
    <tr><td class="paramname">seed</td><td>seed given to a rng when generating random vectors; a default value 0 initializes the rng randomly with std::random_device </td></tr>
    <tr><td class="paramname">indices_test</td><td>parameter used by the version which uses no separate test set, leave empty. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7a6325435fc140ac5394c2f0136ea211"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a6325435fc140ac5394c2f0136ea211">&#9670;&nbsp;</a></span>grow() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Mrpt::grow </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXf &gt; &amp;&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>trees_max</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depth_max</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depth_min_</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>votes_max_</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>density_</em> = <code>-1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>seed</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Build an autotuned index without prespecifying a recall level.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Q</td><td>Eigen ref to the test queries. </td></tr>
    <tr><td class="paramname">k_</td><td>number of nearest neighbors searched for </td></tr>
    <tr><td class="paramname">trees_max</td><td>number of trees grown; default value -1 sets this to <img class="formulaInl" alt="$ \mathrm{min}(\sqrt{n}, 1000)$" src="form_16.png"/>, where <img class="formulaInl" alt="$n$" src="form_10.png"/> is the number of data points. </td></tr>
    <tr><td class="paramname">depth_max</td><td>depth of trees grown; ; on the set <img class="formulaInl" alt="$\{1,2, \dots ,\lfloor \log_2 (n) \rfloor \}$" src="form_4.png"/>, where <img class="formulaInl" alt="$n $" src="form_5.png"/> is the number of data points; default value -1 sets this to <img class="formulaInl" alt="$ \log_2(n) - 4 $" src="form_9.png"/>, where <img class="formulaInl" alt="$n$" src="form_10.png"/> is the number of data points </td></tr>
    <tr><td class="paramname">depth_min_</td><td>minimum depth of trees considered when searching for optimal parameters on the set <img class="formulaInl" alt="$\{1,2, \dots ,\lfloor \log_2 (n) \rfloor \}$" src="form_4.png"/>; a default value -1 sets this to 5 </td></tr>
    <tr><td class="paramname">votes_max_</td><td>maximum number of votes considered when searching for optimal parameters; a default value -1 sets this to <img class="formulaInl" alt="$ \mathrm{max}(\lfloor \mathrm{trees\_max} / 10 \rfloor, 10) $" src="form_14.png"/> </td></tr>
    <tr><td class="paramname">density_</td><td>expected proportion of non-zero components of random vectors; default value -1.0 sets this to <img class="formulaInl" alt="$ 1 / \sqrt{d} $" src="form_2.png"/>, where <img class="formulaInl" alt="$ d$" src="form_13.png"/> is the dimension of data </td></tr>
    <tr><td class="paramname">seed</td><td>seed given to a rng when generating random vectors; a default value 0 initializes the rng randomly with std::random_device </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6911b63fb6fb87129f893831391f42dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6911b63fb6fb87129f893831391f42dd">&#9670;&nbsp;</a></span>grow_autotune() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Mrpt::grow_autotune </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>target_recall</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>trees_max</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depth_max</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depth_min_</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>votes_max_</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>density_</em> = <code>-1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>seed</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n_test</em> = <code>100</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Build an autotuned index sampling test queries from the training set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target_recall</td><td>target recall level; on the range [0,1] </td></tr>
    <tr><td class="paramname">n_test</td><td>number of test queries </td></tr>
    <tr><td class="paramname">k_</td><td>number of nearest neighbors searched for </td></tr>
    <tr><td class="paramname">trees_max</td><td>number of trees grown; default value -1 sets this to <img class="formulaInl" alt="$ \mathrm{min}(\sqrt{n}, 1000)$" src="form_16.png"/>, where <img class="formulaInl" alt="$n$" src="form_10.png"/> is the number of data points. </td></tr>
    <tr><td class="paramname">depth_max</td><td>maximum depth of trees considered when searching for optimal parameters; in the set <img class="formulaInl" alt="$\{1,2, \dots ,\lfloor \log_2 (n) \rfloor \}$" src="form_4.png"/>, where <img class="formulaInl" alt="$n $" src="form_5.png"/> is the number of data points; default value -1 sets this to <img class="formulaInl" alt="$ \log_2(n) - 4 $" src="form_9.png"/>, where <img class="formulaInl" alt="$n$" src="form_10.png"/> is the number of data points </td></tr>
    <tr><td class="paramname">depth_min_</td><td>minimum depth of trees considered when searching for optimal parameters; in the set <img class="formulaInl" alt="$\{1,2, \dots ,\lfloor \log_2 (n) \rfloor \}$" src="form_4.png"/>; a default value -1 sets this to 5 </td></tr>
    <tr><td class="paramname">votes_max_</td><td>maximum number of votes considered when searching for optimal parameters; a default value -1 sets this to <img class="formulaInl" alt="$ \mathrm{max}(\lfloor \mathrm{trees\_max} / 10 \rfloor, 10) $" src="form_14.png"/> </td></tr>
    <tr><td class="paramname">density_</td><td>expected proportion of non-zero components in the random vectors; default value -1.0 sets this to <img class="formulaInl" alt="$ 1 / \sqrt{d} $" src="form_2.png"/>, where <img class="formulaInl" alt="$ d$" src="form_13.png"/> is the dimension of data </td></tr>
    <tr><td class="paramname">seed</td><td>seed given to a rng when generating random vectors; a default value 0 initializes the rng randomly with std::random_device </td></tr>
    <tr><td class="paramname">n_test</td><td>number of test queries sampled from the training set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9ee717a90c0548f31577b033540dda44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ee717a90c0548f31577b033540dda44">&#9670;&nbsp;</a></span>grow_autotune() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Mrpt::grow_autotune </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>trees_max</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depth_max</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depth_min_</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>votes_max_</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>density_</em> = <code>-1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>seed</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n_test</em> = <code>100</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Build an autotuned index sampling test queries from the training set and without prespecifying a recall level.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k_</td><td>number of nearest neighbors searched for </td></tr>
    <tr><td class="paramname">trees_max</td><td>number of trees grown; default value -1 sets this to <img class="formulaInl" alt="$ \mathrm{min}(\sqrt{n}, 1000)$" src="form_16.png"/>, where <img class="formulaInl" alt="$n$" src="form_10.png"/> is the number of data points. </td></tr>
    <tr><td class="paramname">depth_max</td><td>depth of trees grown; in the set <img class="formulaInl" alt="$\{1,2, \dots ,\lfloor \log_2 (n) \rfloor \}$" src="form_4.png"/>, where <img class="formulaInl" alt="$n $" src="form_5.png"/> is the number of data points; default value -1 sets this to <img class="formulaInl" alt="$ \log_2(n) - 4 $" src="form_9.png"/>, where <img class="formulaInl" alt="$n$" src="form_10.png"/> is the number of data points </td></tr>
    <tr><td class="paramname">depth_min_</td><td>minimum depth of trees considered when searching for optimal parameters on the set <img class="formulaInl" alt="$\{1,2, \dots ,\lfloor \log_2 (n) \rfloor \}$" src="form_4.png"/>; a default value -1 sets this to 5 </td></tr>
    <tr><td class="paramname">votes_max_</td><td>maximum number of votes considered when searching for optimal parameters; a default value -1 sets this to <img class="formulaInl" alt="$ \mathrm{max}(\lfloor \mathrm{trees\_max} / 10 \rfloor, 10) $" src="form_14.png"/> </td></tr>
    <tr><td class="paramname">density_</td><td>expected proportion of non-zero components of random vectors; default value -1.0 sets this to <img class="formulaInl" alt="$ 1 / \sqrt{d} $" src="form_2.png"/>, where <img class="formulaInl" alt="$ d$" src="form_13.png"/> is the dimension of data </td></tr>
    <tr><td class="paramname">seed</td><td>seed given to a rng when generating random vectors; a default value 0 initializes the rng randomly with std::random_device </td></tr>
    <tr><td class="paramname">n_test</td><td>number of test queries sampled from the training set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a64adc0d6952d12e4599459f8654e860e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64adc0d6952d12e4599459f8654e860e">&#9670;&nbsp;</a></span>is_autotuned()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Mrpt::is_autotuned </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get whether the index has been autotuned.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the index has been autotuned, false otherwise. </dd></dl>

</div>
</div>
<a id="af31f777278ec7030e7351b6ed57ca766"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af31f777278ec7030e7351b6ed57ca766">&#9670;&nbsp;</a></span>load()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Mrpt::load </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Loads an index from a file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>filepath to the index file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if loading succeeded, false otherwise. </dd></dl>

</div>
</div>
<a id="a0907893c90a6255d3cf8d11e940c6ce3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0907893c90a6255d3cf8d11e940c6ce3">&#9670;&nbsp;</a></span>optimal_parameters()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="struct_mrpt___parameters.html">Mrpt_Parameters</a>&gt; Mrpt::optimal_parameters </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the pareto frontier of optimal parameters for an index which is autotuned without setting a recall level. This means that each parameter combination in a returned vector is optimal in a sense that it is a fastest (measured by query time) parameter combination to obtain as least as high recall level that it has.</p>
<dl class="section return"><dt>Returns</dt><dd>vector of optimal parameters </dd></dl>

</div>
</div>
<a id="a82a6cd3ce04ff8307bfd00d99fc5400a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82a6cd3ce04ff8307bfd00d99fc5400a">&#9670;&nbsp;</a></span>parameters()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_mrpt___parameters.html">Mrpt_Parameters</a> Mrpt::parameters </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the optimal parameters and the estimated recall and query time found by autotuning. If the index is autotuned without preset recall level, <code>estimated_recall</code>, <code>estimated_qtime</code> and <code>votes</code> are set to their default value 0, and <code>n_trees</code> and <code>depth</code> are set to <code>trees_max</code> and <code>depth_max, respectively. If the index is not autotuned, </code>estimated_recall<code>,</code>estimated_qtime<code>,</code>votes<code>and</code>k` are all set to their default value 0.</p>
<dl class="section return"><dt>Returns</dt><dd>parameters of the index </dd></dl>

</div>
</div>
<a id="a637e67fe6eba9a6711f5eee65ad4a0da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a637e67fe6eba9a6711f5eee65ad4a0da">&#9670;&nbsp;</a></span>query() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Mrpt::query </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vote_threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>out_distances</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>out_n_elected</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Approximate k-nn search using a normal index.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>pointer to an array containing the query point </td></tr>
    <tr><td class="paramname">k</td><td>number of nearest neighbors searched for </td></tr>
    <tr><td class="paramname">vote_threshold</td><td>- number of votes required for a query point to be included in the candidate set </td></tr>
    <tr><td class="paramname">out</td><td>output buffer (size = k) for the indices of k approximate nearest neighbors </td></tr>
    <tr><td class="paramname">out_distances</td><td>optional output buffer (size = k) for distances to k approximate nearest neighbors </td></tr>
    <tr><td class="paramname">out_n_elected</td><td>optional output parameter (size = 1) for the candidate set size </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a35235eb7acf4bff5fbfb12c9cd82f0b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35235eb7acf4bff5fbfb12c9cd82f0b8">&#9670;&nbsp;</a></span>query() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Mrpt::query </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXf &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vote_threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>out_distances</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>out_n_elected</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Approximate k-nn search using a normal index.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>Eigen ref to the query point </td></tr>
    <tr><td class="paramname">k</td><td>number of nearest neighbors searched for </td></tr>
    <tr><td class="paramname">vote_threshold</td><td>number of votes required for a query point to be included in the candidate set </td></tr>
    <tr><td class="paramname">out</td><td>output buffer (size = k) for the indices of k approximate nearest neighbors </td></tr>
    <tr><td class="paramname">out_distances</td><td>optional output buffer (size = k) for distances to k approximate nearest neighbors </td></tr>
    <tr><td class="paramname">out_n_elected</td><td>optional output parameter (size = 1) for the candidate set size </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a16fac96c266abcc778694e0b0cdc5f3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16fac96c266abcc778694e0b0cdc5f3c">&#9670;&nbsp;</a></span>query() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Mrpt::query </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>out_distances</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>out_n_elected</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Approximate k-nn search using an autotuned index.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>pointer to an array containing the query point </td></tr>
    <tr><td class="paramname">out</td><td>output buffer (size = k) for the indices of k approximate nearest neighbors </td></tr>
    <tr><td class="paramname">out_distances</td><td>optional output buffer (size = k) for distances to k approximate nearest neighbors </td></tr>
    <tr><td class="paramname">out_n_elected</td><td>optional output parameter (size = 1) for the candidate set size </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9579b70d0553126363f6112a10ffb0eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9579b70d0553126363f6112a10ffb0eb">&#9670;&nbsp;</a></span>query() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Mrpt::query </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXf &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>out_distances</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>out_n_elected</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Approximate k-nn search using an autotuned index.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>Eigen ref to the query point </td></tr>
    <tr><td class="paramname">out</td><td>output buffer (size = k) for the indices of k approximate nearest neighbors </td></tr>
    <tr><td class="paramname">out_distances</td><td>optional output buffer (size = k) for distances to k approximate nearest neighbors </td></tr>
    <tr><td class="paramname">out_n_elected</td><td>optional output parameter (size = 1) for the candidate set size </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af936713e7629e08e88d11346f2639ba0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af936713e7629e08e88d11346f2639ba0">&#9670;&nbsp;</a></span>save()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Mrpt::save </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Saves the index to a file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>- filepath to the output file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if saving succeeded, false otherwise. </dd></dl>

</div>
</div>
<a id="add8686a73cfae8d8391e85314acbe81a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add8686a73cfae8d8391e85314acbe81a">&#9670;&nbsp;</a></span>subset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_mrpt.html">Mrpt</a> Mrpt::subset </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>target_recall</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a new index by copying trees from an autotuned index grown without a prespecified recall level. The index is created so that it gives a fastest query time at the recall level given as the parameter. If this recall level is not met, then it creates an index with a highest possible recall level.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target_recall</td><td>target recall level; on the range [0,1] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an autotuned <a class="el" href="class_mrpt.html">Mrpt</a> index with a recall level at least as high as target_recall </dd></dl>

</div>
</div>
<a id="a4dc319eab5e2bc9a5a6d7a6007cef34d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dc319eab5e2bc9a5a6d7a6007cef34d">&#9670;&nbsp;</a></span>subset_pointer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_mrpt.html">Mrpt</a>* Mrpt::subset_pointer </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>target_recall</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a new index by copying trees from an autotuned index grown without a prespecified recall level. The index is created so that it gives a fastest query time at the recall level given as the parameter. If this recall level is not met, then it creates an index with a highest possible recall level. This function differs from <a class="el" href="class_mrpt.html#add8686a73cfae8d8391e85314acbe81a">subset()</a> only by the return value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target_recall</td><td>target recall level; on the range [0,1] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to a dynamically allocated autotuned <a class="el" href="class_mrpt.html">Mrpt</a> index with a recall level at least as high as target_recall </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>cpp/<a class="el" href="_mrpt_8h_source.html">Mrpt.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
